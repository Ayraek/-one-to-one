import os
import re
import logging
import sqlite3
import asyncio
from dotenv import load_dotenv

from openai import OpenAI

from aiogram import Bot, Dispatcher, Router, F, types
from aiogram.types import Message, CallbackQuery, InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.state import StatesGroup, State

####################################
# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
####################################

load_dotenv()
API_TOKEN = os.getenv("API_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

####################################
# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ OpenAI –∫–ª–∏–µ–Ω—Ç–∞
####################################

client = OpenAI(api_key=OPENAI_API_KEY)

####################
# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
####################

logging.basicConfig(level=logging.INFO)

####################################
# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞/–¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞
####################################

bot = Bot(token=API_TOKEN)
storage = MemoryStorage()
dp = Dispatcher(storage=storage)
router = Router()
dp.include_router(router)

#########################
# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
#########################

LEVELS = ["Junior", "Middle", "Senior", "Head of Product", "CPO", "CEO"]

welcome_text = (
    "üí° –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ \"One to One Booster bot\" ‚Äî –≤–∞—à–µ–≥–æ –ª–∏—á–Ω–æ–≥–æ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞ –¥–ª—è –ø—Ä–æ–∫–∞—á–∫–∏ –Ω–∞–≤—ã–∫–æ–≤ "
    "–≤ –ø—Ä–æ–¥–∞–∫—Ç-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç–µ!\n\n–ù–∞–∂–º–∏—Ç–µ /start, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å üî•"
)

TOPICS = [
    "–ì–∏–ø–æ—Ç–µ–∑—ã",
    "–ú–∞—Ä–∫–µ—Ç–∏–Ω–≥",
    "–ú–µ—Ç—Ä–∏–∫–∏",
    "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥–æ–π",
    "Soft skills",
    "–°—Ç—Ä–∞—Ç–µ–≥–∏—è",
    "–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ –ø—Ä–æ–¥—É–∫—Ç—É",
]

####################################
# –ú–µ–Ω—é
####################################

def get_main_menu():
    keyboard = [
        [InlineKeyboardButton(text="üë§ –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å", callback_data="profile")],
        [InlineKeyboardButton(text="üìö –ü–æ–ª—É—á–∏—Ç—å –∑–∞–¥–∞–Ω–∏–µ", callback_data="task")],
        [InlineKeyboardButton(text="‚ùì –ü–æ–º–æ—â—å", callback_data="help")]
    ]
    return InlineKeyboardMarkup(inline_keyboard=keyboard)

def get_grades_menu():
    keyboard = [
        [InlineKeyboardButton(text="üë∂ Junior", callback_data="grade_Junior")],
        [InlineKeyboardButton(text="üßë Middle", callback_data="grade_Middle")],
        [InlineKeyboardButton(text="üë®‚Äçüíº Senior", callback_data="grade_Senior")],
        [InlineKeyboardButton(text="üíº Head of Product", callback_data="grade_Head of Product")],
        [InlineKeyboardButton(text="üìä CPO", callback_data="grade_CPO")],
        [InlineKeyboardButton(text="üöÄ CEO", callback_data="grade_CEO")],
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="main_menu")]
    ]
    return InlineKeyboardMarkup(inline_keyboard=keyboard)

def get_topics_menu():
    buttons = []
    for topic in TOPICS:
        buttons.append([InlineKeyboardButton(text=topic, callback_data=f"topic_{topic}")])
    buttons.append([InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="choose_grade")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)

####################################
# –†–∞–±–æ—Ç–∞ —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö
####################################

def add_user_to_db(user_id: int, username: str, name: str, age: int):
    with sqlite3.connect('users.db') as conn:
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY,
                username TEXT,
                name TEXT,
                age INTEGER,
                level TEXT,
                points REAL
            )
        ''')
        cursor.execute('''
            INSERT OR IGNORE INTO users (id, username, name, age, level, points)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (user_id, username, name, age, "Junior", 0.0))
        conn.commit()

def get_user_from_db(user_id: int):
    with sqlite3.connect('users.db') as conn:
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM users WHERE id = ?', (user_id,))
        return cursor.fetchone()

def update_user_points(user_id: int, additional_points: float):
    with sqlite3.connect('users.db') as conn:
        cursor = conn.cursor()
        cursor.execute('UPDATE users SET points = points + ? WHERE id = ?', (additional_points, user_id))
        conn.commit()

def update_level(user_id: int):
    user = get_user_from_db(user_id)
    if not user:
        return
    _, username, name, age, current_level, points = user
    cur_index = LEVELS.index(current_level)
    required_points = 50 * (cur_index + 1)
    if points >= required_points and cur_index < len(LEVELS) - 1:
        new_level = LEVELS[cur_index + 1]
        with sqlite3.connect('users.db') as conn:
            cursor = conn.cursor()
            cursor.execute('UPDATE users SET level = ? WHERE id = ?', (new_level, user[0]))
            conn.commit()
        logging.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user[0]} –ø–æ–≤—ã—à–µ–Ω —Å {current_level} –¥–æ {new_level}.")

####################################
# –°–æ—Å—Ç–æ—è–Ω–∏—è
####################################

class RegisterState(StatesGroup):
    name = State()
    age = State()

class TaskState(StatesGroup):
    waiting_for_answer = State()

####################################
# –ö–æ–º–∞–Ω–¥—ã
####################################

@router.message(lambda msg: msg.text == "/start")
async def cmd_start(message: Message, state: FSMContext):
    user = get_user_from_db(message.from_user.id)
    if user is None:
        await message.answer_photo(
            photo="https://i.imgur.com/zIPzQKF.jpeg",
            caption="–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ One to One IT Academy!"
        )
        await message.answer("üëã –î–∞–≤–∞–π –∑–Ω–∞–∫–æ–º–∏–º—Å—è! –ö–∞–∫ —Ç–µ–±—è –∑–æ–≤—É—Ç?")
        await state.set_state(RegisterState.name)
    else:
        _, username, name, age, level, points = user
        await message.answer(f"üëã –ü—Ä–∏–≤–µ—Ç, {name}!")
        await message.answer(welcome_text, reply_markup=get_main_menu())

@router.message(RegisterState.name)
async def process_name(message: Message, state: FSMContext):
    await state.update_data(name=message.text)
    await message.answer("–°–∫–æ–ª—å–∫–æ —Ç–µ–±–µ –ª–µ—Ç?")
    await state.set_state(RegisterState.age)

@router.message(RegisterState.age)
async def process_age(message: Message, state: FSMContext):
    if not message.text.isdigit():
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–æ–∑—Ä–∞—Å—Ç —á–∏—Å–ª–æ–º (—Ü–∏—Ñ—Ä–∞–º–∏).")
        return
    data = await state.get_data()
    name = data.get("name")
    add_user_to_db(
        user_id=message.from_user.id,
        username=message.from_user.username or "",
        name=name,
        age=int(message.text)
    )
    await message.answer(f"‚úÖ –ì–æ—Ç–æ–≤–æ, {name}! –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!", reply_markup=get_main_menu())
    await state.clear()

@router.message(lambda msg: msg.text == "/ping")
async def cmd_ping(message: Message):
    await message.answer("üèì Pong!")

####################################
# –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ CallbackQuery
####################################

@router.callback_query(F.data == "profile")
async def profile_callback(callback: CallbackQuery):
    user = get_user_from_db(callback.from_user.id)
    if not user:
        await callback.message.edit_text("üö´ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–Ω–æ–≤–æ /start.", reply_markup=get_main_menu())
        await callback.answer()
        return

    _, username, name, age, level, points = user
    with sqlite3.connect('users.db') as conn:
        cursor = conn.cursor()
        cursor.execute('SELECT id FROM users ORDER BY points DESC')
        all_ids = [row[0] for row in cursor.fetchall()]
        rank = all_ids.index(callback.from_user.id) + 1 if callback.from_user.id in all_ids else '‚Äî'

    text = (
        f"<b>üë§ –ò–º—è:</b> {name}\n"
        f"<b>üéÇ –í–æ–∑—Ä–∞—Å—Ç:</b> {age}\n"
        f"<b>üéØ –£—Ä–æ–≤–µ–Ω—å:</b> {level}\n"
        f"<b>‚≠ê –ë–∞–ª–ª—ã:</b> {points}\n"
        f"<b>üèÜ –ú–µ—Å—Ç–æ –≤ —Ä–µ–π—Ç–∏–Ω–≥–µ:</b> {rank}"
    )
    await callback.message.answer(text, parse_mode="HTML", reply_markup=get_main_menu())
    await callback.answer()

@router.callback_query(F.data == "help")
async def help_callback(callback: CallbackQuery):
    text = (
        "‚ÑπÔ∏è –ü–æ–º–æ—â—å:\n"
        "/start ‚Äî –Ω–∞—á–∞—Ç—å\n"
        "üìö –ü–æ–ª—É—á–∏—Ç—å –∑–∞–¥–∞–Ω–∏–µ ‚Äî –≤—ã–±—Ä–∞—Ç—å –≥—Ä–µ–π–¥ –∏ —Ç–µ–º—É, –∑–∞—Ç–µ–º —Ä–µ—à–∏—Ç—å –∫–µ–π—Å."
    )
    await callback.message.edit_text(text, reply_markup=get_main_menu())
    await callback.answer()

@router.callback_query(F.data == "main_menu")
async def main_menu_callback(callback: CallbackQuery):
    user = get_user_from_db(callback.from_user.id)
    if user:
        _, username, name, age, level, points = user
        text = (
            f"<b>üë§ –ò–º—è:</b> {name}\n"
            f"<b>üéÇ –í–æ–∑—Ä–∞—Å—Ç:</b> {age}\n"
            f"<b>üéØ –£—Ä–æ–≤–µ–Ω—å:</b> {level}\n"
            f"<b>‚≠ê –ë–∞–ª–ª—ã:</b> {points}\n"
        )
        await callback.message.edit_text(text, parse_mode="HTML", reply_markup=get_main_menu())
    else:
        await callback.message.edit_text(welcome_text, reply_markup=get_main_menu())
    await callback.answer()

@router.callback_query(F.data == "task")
async def task_callback(callback: CallbackQuery):
    await callback.message.edit_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ –≥—Ä–µ–π–¥, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ —Ö–æ—Ç–∏—Ç–µ –ø–æ–ª—É—á–∏—Ç—å –∑–∞–¥–∞–Ω–∏–µ:",
        reply_markup=get_grades_menu()
    )
    await callback.answer()

@router.callback_query(F.data.startswith("grade_"))
async def handle_grade_selection(callback: CallbackQuery, state: FSMContext):
    selected_grade = callback.data.replace("grade_", "").strip()

    user = get_user_from_db(callback.from_user.id)
    if not user:
        await callback.message.answer("üö´ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ /start", reply_markup=get_main_menu())
        await callback.answer()
        return

    current_level = user[4]
    if selected_grade != current_level:
        await callback.message.answer(
            f"üö´ –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω! –í–∞—à —Ç–µ–∫—É—â–∏–π —É—Ä–æ–≤–µ–Ω—å: {current_level}.",
            reply_markup=get_main_menu()
        )
        await callback.answer()
        return

    await state.update_data(selected_grade=selected_grade)
    await callback.message.edit_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–µ–º—É –¥–ª—è –∑–∞–¥–∞–Ω–∏—è:",
        reply_markup=get_topics_menu()
    )
    await callback.answer()

@router.callback_query(F.data == "choose_grade")
async def back_to_grades(callback: CallbackQuery):
    await callback.message.edit_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ –≥—Ä–µ–π–¥, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ —Ö–æ—Ç–∏—Ç–µ –ø–æ–ª—É—á–∏—Ç—å –∑–∞–¥–∞–Ω–∏–µ:",
        reply_markup=get_grades_menu()
    )
    await callback.answer()

@router.callback_query(F.data.startswith("topic_"))
async def handle_topic_selection(callback: CallbackQuery, state: FSMContext):
    chosen_topic = callback.data.replace("topic_", "").strip()

    data = await state.get_data()
    selected_grade = data.get("selected_grade")
    if not selected_grade:
        await callback.message.answer(
            "‚ö†Ô∏è –û—à–∏–±–∫–∞: –Ω–µ –Ω–∞–π–¥–µ–Ω –≥—Ä–µ–π–¥. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–∞—á–∞–ª–∞ –≤—ã–±—Ä–∞—Ç—å –≥—Ä–µ–π–¥ –∑–∞–Ω–æ–≤–æ.",
            reply_markup=get_grades_menu()
        )
        await callback.answer()
        return

    question = await generate_question(selected_grade, chosen_topic)
    await state.set_state(TaskState.waiting_for_answer)
    await state.update_data(question=question, grade=selected_grade, last_score=0.0)
    await callback.message.edit_text(
        f"üí¨ –ó–∞–¥–∞–Ω–∏–µ –¥–ª—è —É—Ä–æ–≤–Ω—è {selected_grade} –ø–æ —Ç–µ–º–µ ¬´{chosen_topic}¬ª:\n\n"
        f"{question}\n\n"
        "‚úçÔ∏è –ù–∞–ø–∏—à–∏—Ç–µ —Å–≤–æ–π –æ—Ç–≤–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ–º."
    )
    await callback.answer()

@router.message(TaskState.waiting_for_answer)
async def handle_task_answer(message: Message, state: FSMContext):
    data = await state.get_data()
    if not data:
        await message.answer("‚ö†Ô∏è –ù–µ –Ω–∞–π–¥–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –∑–∞–¥–∞–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        return

    grade = data.get("grade")
    question = data.get("question")
    last_score = data.get("last_score", 0.0)

    user = get_user_from_db(message.from_user.id)
    if not user:
        await message.answer("üö´ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ /start.")
        return

    student_name = user[2]
    feedback_raw = await evaluate_answer(question, message.text, student_name)
    logging.info(f"RAW FEEDBACK:\n{feedback_raw}")

    pattern = r"–ö—Ä–∏—Ç–µ—Ä–∏–∏:\s*(.*?)Score:\s*([\d.]+)\s*Feedback:\s*(.*)"
    match = re.search(pattern, feedback_raw, re.DOTALL)
    if match:
        criteria_block = match.group(1).strip()
        try:
            new_score = float(match.group(2))
        except ValueError:
            new_score = 0.0
        feedback_text = match.group(3).strip()
    else:
        criteria_block = ""
        new_score = 0.0
        feedback_text = feedback_raw.strip()

    if new_score > last_score:
        diff = new_score - last_score
        update_user_points(message.from_user.id, diff)
        update_level(message.from_user.id)
        await state.update_data(last_score=new_score)

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="üîÅ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞", callback_data="retry"),
            InlineKeyboardButton(text="‚úÖ –ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç", callback_data="show_answer")
        ],
        [InlineKeyboardButton(text="üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="main_menu")]
    ])

    result_msg = ""
    if criteria_block:
        result_msg += f"<b>–ö—Ä–∏—Ç–µ—Ä–∏–∏:</b>\n{criteria_block}\n\n"
    result_msg += f"<b>–û—Ü–µ–Ω–∫–∞ (Score):</b> {new_score}\n\n"
    result_msg += f"<b>–û–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å (Feedback):</b>\n{feedback_text}"

    if len(result_msg) > 4000:
        chunks = [result_msg[i:i+4000] for i in range(0, len(result_msg), 4000)]
        for i, chunk in enumerate(chunks):
            if i == len(chunks) - 1:
                await message.answer(chunk, parse_mode="HTML", reply_markup=keyboard)
            else:
                await message.answer(chunk, parse_mode="HTML")
    else:
        await message.answer(result_msg, parse_mode="HTML", reply_markup=keyboard)

    await state.update_data(last_question=question, last_grade=grade)

@router.callback_query(F.data == "show_answer")
async def show_correct_answer(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    question = data.get("last_question")
    grade = data.get("last_grade")
    if not question or not grade:
        await callback.message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞: –Ω–µ –Ω–∞–π–¥–µ–Ω –≤–æ–ø—Ä–æ—Å –¥–ª—è –ø–æ–∫–∞–∑–∞ –æ—Ç–≤–µ—Ç–∞.", reply_markup=get_main_menu())
        await callback.answer()
        return

    correct = await generate_correct_answer(question, grade)
    await callback.message.answer(
        f"‚úÖ –≠—Ç–∞–ª–æ–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç —É—Ä–æ–≤–Ω—è {grade}:\n\n{correct}",
        parse_mode="HTML",
        reply_markup=get_main_menu()
    )
    await callback.answer()

@router.callback_query(F.data == "retry")
async def retry_question(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    question = data.get("last_question")
    grade = data.get("last_grade")
    if not question or not grade:
        await callback.message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞: –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–≥–æ –∑–∞–¥–∞–Ω–∏—è.", reply_markup=get_main_menu())
        await callback.answer()
        return

    await state.set_state(TaskState.waiting_for_answer)
    await state.update_data(question=question, grade=grade, last_score=data.get("last_score", 0.0))
    await callback.message.answer(
        f"‚úçÔ∏è –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–≤–µ—Ç –Ω–∞ –≤–æ–ø—Ä–æ—Å —É—Ä–æ–≤–Ω—è {grade}:\n\n{question}"
    )
    await callback.answer()

####################################
# OpenAI —Ñ—É–Ω–∫—Ü–∏–∏
####################################

async def generate_question(grade: str, topic: str) -> str:
    """
    –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∫—Ä–∞—Ç–∫–∏–π –≤–æ–ø—Ä–æ—Å (–¥–æ 800 —Å–∏–º–≤–æ–ª–æ–≤) –¥–ª—è –ø—Ä–æ–¥–∞–∫—Ç-–º–µ–Ω–µ–¥–∂–µ—Ä–∞ —É—Ä–æ–≤–Ω—è {grade}
    –ø–æ —Ç–µ–º–µ {topic} –±–µ–∑ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∑–≤—ë–∑–¥–æ—á–µ–∫.
    –ï—Å–ª–∏ –≤–æ–ø—Ä–æ—Å –ø—Ä–µ–≤—ã—à–∞–µ—Ç 800 —Å–∏–º–≤–æ–ª–æ–≤, –æ–Ω –æ–±—Ä–µ–∑–∞–µ—Ç—Å—è.
    """
    prompt = (
        f"–¢—ã –æ–ø—ã—Ç–Ω—ã–π –ø—Ä–æ–¥–∞–∫—Ç-–º–µ–Ω–µ–¥–∂–µ—Ä. –°—Ñ–æ—Ä–º—É–ª–∏—Ä—É–π –∫–æ—Ä–æ—Ç–∫–∏–π, —Ç–æ—á–Ω—ã–π –≤–æ–ø—Ä–æ—Å –¥–ª—è —É—Ä–æ–≤–Ω—è {grade} "
        f"–ø–æ —Ç–µ–º–µ ¬´{topic}¬ª. –ù–µ –±–æ–ª–µ–µ 800 —Å–∏–º–≤–æ–ª–æ–≤, —Ç–æ–ª—å–∫–æ —Å–∞–º–æ–µ –≤–∞–∂–Ω–æ–µ. –ò–∑–±–µ–≥–∞–π –∑–≤—ë–∑–¥–æ—á–µ–∫; –º–æ–∂–µ—à—å –ø—Ä–∏–º–µ–Ω—è—Ç—å —ç–º–æ–¥–∑–∏. "
        "–ù–µ –æ–±—Ä—ã–≤–∞–π —Ñ—Ä–∞–∑—É –≤ –∫–æ–Ω—Ü–µ."
    )
    try:
        response = await asyncio.to_thread(
            client.chat.completions.create,
            model="gpt-3.5-turbo",
            messages=[
                {
                    "role": "system",
                    "content": (
                        "–¢—ã –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—à—å –∫—Ä–∞—Ç–∫–∏–µ –≤–æ–ø—Ä–æ—Å—ã –¥–ª—è –ø—Ä–æ–¥–∞–∫—Ç-–º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤. "
                        "–ù–µ –∏—Å–ø–æ–ª—å–∑—É–π —Å–∏–º–≤–æ–ª * (–∑–≤—ë–∑–¥–æ—á–∫–∞). –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ 800 —Å–∏–º–≤–æ–ª–æ–≤."
                    )
                },
                {"role": "user", "content": prompt}
            ],
            max_tokens=250,
            temperature=0.6
        )
        question_text = response.choices[0].message.content.strip()
        if len(question_text) > 800:
            question_text = question_text[:797] + "..."
        return question_text
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–æ–ø—Ä–æ—Å–∞: {e}")
        return "‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–æ–ø—Ä–æ—Å–∞."

async def evaluate_answer(question: str, student_answer: str, student_name: str) -> str:
    prompt = (
        f"–í–æ–ø—Ä–æ—Å: {question}\n"
        f"–û—Ç–≤–µ—Ç —Å—Ç—É–¥–µ–Ω—Ç–∞: {student_answer}\n\n"
        "–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –æ—Ç–≤–µ—Ç –ø–æ 5 –∫—Ä–∏—Ç–µ—Ä–∏—è–º:\n"
        "1. –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –≤–æ–ø—Ä–æ—Å—É\n"
        "2. –ü–æ–ª–Ω–æ—Ç–∞\n"
        "3. –ê—Ä–≥—É–º–µ–Ω—Ç–∞—Ü–∏—è\n"
        "4. –°—Ç—Ä—É–∫—Ç—É—Ä–∞\n"
        "5. –ü—Ä–∏–º–µ—Ä—ã\n\n"
        "–î–ª—è –∫–∞–∂–¥–æ–≥–æ –∫—Ä–∏—Ç–µ—Ä–∏—è –≤—ã–±–µ—Ä–∏ –æ–¥–∏–Ω –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤: ‚úÖ, ‚ö†Ô∏è –∏–ª–∏ ‚ùå.\n"
        "–û–ø—Ä–µ–¥–µ–ª–∏ –∏—Ç–æ–≥–æ–≤—É—é –æ—Ü–µ–Ω–∫—É (Score) –æ—Ç 0.0 –¥–æ 1.0. –ï—Å–ª–∏ –æ—Ç–≤–µ—Ç —á–∞—Å—Ç–∏—á–Ω–æ –≤–µ—Ä–Ω—ã–π, –∏—Å–ø–æ–ª—å–∑—É–π –¥—Ä–æ–±–Ω–æ–µ —á–∏—Å–ª–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 0.5).\n\n"
        "–í—ã–≤–µ–¥–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å—Ç—Ä–æ–≥–æ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n\n"
        "–ö—Ä–∏—Ç–µ—Ä–∏–∏:\n"
        "üîπ –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –≤–æ–ø—Ä–æ—Å—É: <—ç–º–æ–¥–∂–∏>\n"
        "üîπ –ü–æ–ª–Ω–æ—Ç–∞: <—ç–º–æ–¥–∂–∏>\n"
        "üîπ –ê—Ä–≥—É–º–µ–Ω—Ç–∞—Ü–∏—è: <—ç–º–æ–¥–∂–∏>\n"
        "üîπ –°—Ç—Ä—É–∫—Ç—É—Ä–∞: <—ç–º–æ–¥–∂–∏>\n"
        "üîπ –ü—Ä–∏–º–µ—Ä—ã: <—ç–º–æ–¥–∂–∏>\n\n"
        "Score: <—á–∏—Å–ª–æ>\n"
        "Feedback: –í–∞—à –æ—Ç–≤–µ—Ç... (–æ–±—Ä–∞—Ç–∏—Å—å –∫ —Å—Ç—É–¥–µ–Ω—Ç—É –æ—Ç –ø–µ—Ä–≤–æ–≥–æ –ª–∏—Ü–∞)\n"
    )
    try:
        response = await asyncio.to_thread(
            client.chat.completions.create,
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "–¢—ã –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å, —Å—Ç—Ä–æ–≥–æ –æ—Ü–µ–Ω–∏–≤–∞—é—â–∏–π –æ—Ç–≤–µ—Ç—ã –ø–æ —Ñ–æ—Ä–º–∞—Ç—É. –ù–µ –¥–æ–±–∞–≤–ª—è–π –ª–∏—à–Ω–∏—Ö —Å–ª–æ–≤."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=450,
            temperature=0.3
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –æ—Ü–µ–Ω–∫–∏ –æ—Ç–≤–µ—Ç–∞: {e}")
        return "‚ùå –û—à–∏–±–∫–∞ –æ—Ü–µ–Ω–∫–∏ –æ—Ç–≤–µ—Ç–∞."

async def generate_correct_answer(question: str, grade: str) -> str:
    """
    –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ø–æ–ª–Ω—ã–π —ç—Ç–∞–ª–æ–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç –¥–ª—è –≤–æ–ø—Ä–æ—Å–∞ –±–µ–∑ –æ–±—Ä–µ–∑–∞–Ω–∏—è.
    """
    prompt = (
        f"–¢—ã –æ–ø—ã—Ç–Ω—ã–π –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å –ø—Ä–æ–¥–∞–∫—Ç-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç–∞. –î–∞–π –ø–æ–¥—Ä–æ–±–Ω—ã–π –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç –Ω–∞ –≤–æ–ø—Ä–æ—Å –¥–ª—è —É—Ä–æ–≤–Ω—è {grade}.\n\n"
        f"–í–æ–ø—Ä–æ—Å: {question}\n\n"
        "–û–±—ä—è—Å–Ω–∏ –∫–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã –∏ –ø—Ä–∏–≤–µ–¥–∏ –ø—Ä–∏–º–µ—Ä—ã, –ø–æ—á–µ–º—É –æ—Ç–≤–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π. "
        "–û—Ç–≤–µ—á–∞–π –æ—Ç –ø–µ—Ä–≤–æ–≥–æ –ª–∏—Ü–∞, –æ–±—Ä–∞—â–∞—è—Å—å –∫ —Å—Ç—É–¥–µ–Ω—Ç—É –∫–∞–∫ '–í–∞—à –æ—Ç–≤–µ—Ç...'. "
        "–ù–µ –∏—Å–ø–æ–ª—å–∑—É–π –∑–≤—ë–∑–¥–æ—á–∫–∏(*)."
    )
    try:
        response = await asyncio.to_thread(
            client.chat.completions.create,
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "–¢—ã –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—à—å –ø–æ–¥—Ä–æ–±–Ω—ã–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã –¥–ª—è —Å—Ç—É–¥–µ–Ω—Ç–æ–≤. –ù–µ –∏—Å–ø–æ–ª—å–∑—É–π –∑–≤—ë–∑–¥–æ—á–∫–∏."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=1000,  # —É–≤–µ–ª–∏—á–µ–Ω–æ –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ —ç—Ç–∞–ª–æ–Ω–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞
            temperature=0.7
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —ç—Ç–∞–ª–æ–Ω–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞: {e}")
        return "‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —ç—Ç–∞–ª–æ–Ω–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞."

####################################
# –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
####################################

if __name__ == "__main__":
    asyncio.run(dp.start_polling(bot, skip_updates=True))
