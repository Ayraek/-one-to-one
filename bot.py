import os
from dotenv import load_dotenv
import sqlite3
import logging
import asyncio
import re
from openai import OpenAI

from aiogram import Bot, Dispatcher, types
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram import Router, F

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()
API_TOKEN = os.getenv("API_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ OpenAI –∫–ª–∏–µ–Ω—Ç–∞
client = OpenAI(api_key=OPENAI_API_KEY)

logging.basicConfig(level=logging.INFO)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞
bot = Bot(token=API_TOKEN)
storage = MemoryStorage()
dp = Dispatcher(storage=storage)
router = Router()
dp.include_router(router)

LEVELS = ["Junior", "Middle", "Senior", "Head of Product", "CPO", "CEO"]

welcome_text = (
    "üí° –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ \"One to One Booster bot\" ‚Äî –≤–∞—à–µ–≥–æ –ª–∏—á–Ω–æ–≥–æ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞ –¥–ª—è –ø—Ä–æ–∫–∞—á–∫–∏ –Ω–∞–≤—ã–∫–æ–≤ –≤ –ø—Ä–æ–¥–∞–∫—Ç-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç–µ!\n\n"
    "–ù–∞–∂–º–∏—Ç–µ /start, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å üî•"
)

# --- –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é ---
def get_main_menu():
    keyboard = [
        [InlineKeyboardButton(text="üë§ –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å", callback_data="profile")],
        [InlineKeyboardButton(text="üìö –ü–æ–ª—É—á–∏—Ç—å –∑–∞–¥–∞–Ω–∏–µ", callback_data="task")],
        [InlineKeyboardButton(text="‚ùì –ü–æ–º–æ—â—å", callback_data="help")]
    ]
    return InlineKeyboardMarkup(inline_keyboard=keyboard)

def get_grades_menu():
    keyboard = [
        [InlineKeyboardButton(text="üë∂ Junior", callback_data="grade_Junior")],
        [InlineKeyboardButton(text="üßë Middle", callback_data="grade_Middle")],
        [InlineKeyboardButton(text="üë®‚Äçüíº Senior", callback_data="grade_Senior")],
        [InlineKeyboardButton(text="üíº Head of Product", callback_data="grade_Head of Product")],
        [InlineKeyboardButton(text="üìä CPO", callback_data="grade_CPO")],
        [InlineKeyboardButton(text="üöÄ CEO", callback_data="grade_CEO")],
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="main_menu")]
    ]
    return InlineKeyboardMarkup(inline_keyboard=keyboard)

# --- –†–∞–±–æ—Ç–∞ —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö ---
def add_user_to_db(user_id, username, name, age):
    with sqlite3.connect('users.db') as conn:
        cursor = conn.cursor()
        cursor.execute('''CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, username TEXT, name TEXT, age INTEGER, level TEXT, points INTEGER)''')
        cursor.execute('''INSERT OR IGNORE INTO users (id, username, name, age, level, points) VALUES (?, ?, ?, ?, ?, ?)''',
                       (user_id, username, name, age, "Junior", 0))
        conn.commit()

def get_user_from_db(user_id):
    with sqlite3.connect('users.db') as conn:
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM users WHERE id = ?', (user_id,))
        return cursor.fetchone()

def update_user_points(user_id, additional_points):
    with sqlite3.connect('users.db') as conn:
        cursor = conn.cursor()
        cursor.execute('UPDATE users SET points = points + ? WHERE id = ?', (additional_points, user_id))
        conn.commit()

def update_level(user_id):
    user = get_user_from_db(user_id)
    if not user:
        return
    _, username, name, age, current_level, points = user
    index = LEVELS.index(current_level) if current_level in LEVELS else 0
    if points >= 50 and index < len(LEVELS) - 1:
        new_level = LEVELS[index + 1]
        with sqlite3.connect('users.db') as conn:
            cursor = conn.cursor()
            cursor.execute('UPDATE users SET level = ? WHERE id = ?', (new_level, user[0]))
            conn.commit()
        logging.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user[0]} –ø–æ–≤—ã—à–µ–Ω —Å {current_level} –¥–æ {new_level}.")

# --- –°–æ—Å—Ç–æ—è–Ω–∏—è ---
class RegisterState(StatesGroup):
    name = State()
    age = State()

class TaskState(StatesGroup):
    waiting_for_answer = State()

# --- –ö–æ–º–∞–Ω–¥—ã ---
@router.message(lambda message: message.text == "/start")
async def cmd_start(message: types.Message, state: FSMContext):
    user = get_user_from_db(message.from_user.id)
    if user is None:
        await message.answer("üëã –î–∞–≤–∞–π –∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è! –ö–∞–∫ —Ç–µ–±—è –∑–æ–≤—É—Ç?")
        await state.set_state(RegisterState.name)
    else:
        _, username, name, age, level, points = user
        await message.answer(f"üëã –ü—Ä–∏–≤–µ—Ç, {name}!")
        await message.answer(welcome_text, reply_markup=get_main_menu())

@router.message(RegisterState.name)
async def process_name(message: types.Message, state: FSMContext):
    await state.update_data(name=message.text)
    await message.answer("–°–∫–æ–ª—å–∫–æ —Ç–µ–±–µ –ª–µ—Ç?")
    await state.set_state(RegisterState.age)

@router.message(RegisterState.age)
async def process_age(message: types.Message, state: FSMContext):
    if not message.text.isdigit():
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏ –≤–æ–∑—Ä–∞—Å—Ç —á–∏—Å–ª–æ–º")
        return
    data = await state.get_data()
    name = data.get("name")
    add_user_to_db(message.from_user.id, message.from_user.username, name, int(message.text))
    await message.answer(f"‚úÖ –ì–æ—Ç–æ–≤–æ, {name}! –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!", reply_markup=get_main_menu())
    await state.clear()

@router.message(lambda message: message.text == "/ping")
async def cmd_ping(message: types.Message):
    await message.answer("üèì Pong!")

# --- Callback-—Ö–µ–Ω–¥–ª–µ—Ä—ã –º–µ–Ω—é ---
@router.callback_query(F.data == "profile")
async def profile_callback(callback: types.CallbackQuery):
    user = get_user_from_db(callback.from_user.id)
    if user:
        _, username, name, age, level, points = user
        with sqlite3.connect('users.db') as conn:
            cursor = conn.cursor()
            cursor.execute('SELECT id FROM users ORDER BY points DESC')
            all_ids = [row[0] for row in cursor.fetchall()]
            rank = all_ids.index(callback.from_user.id) + 1 if callback.from_user.id in all_ids else '‚Äî'

        text = (
            f"<b>üë§ –ò–º—è:</b> {name}\n"
            f"<b>üéÇ –í–æ–∑—Ä–∞—Å—Ç:</b> {age}\n"
            f"<b>üéØ –£—Ä–æ–≤–µ–Ω—å:</b> {level}\n"
            f"<b>‚≠ê –ë–∞–ª–ª—ã:</b> {points}\n"
            f"<b>üèÜ –ú–µ—Å—Ç–æ –≤ —Ä–µ–π—Ç–∏–Ω–≥–µ:</b> {rank}"
        )
        await callback.message.answer_photo(
    photo="https://i.imgur.com/zIPzQKF.jpeg",
    caption="–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ One to One IT Academy!"
)
        await callback.message.answer(text, parse_mode="HTML", reply_markup=get_main_menu())
    else:
        await callback.message.edit_text("üö´ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.", reply_markup=get_main_menu())
    await callback.answer()

@router.callback_query(F.data == "help")
async def help_callback(callback: types.CallbackQuery):
    text = "‚ÑπÔ∏è –ü–æ–º–æ—â—å:\n/start ‚Äî –Ω–∞—á–∞—Ç—å\nüìö –ü–æ–ª—É—á–∏—Ç—å –∑–∞–¥–∞–Ω–∏–µ ‚Äî –≤—ã–±—Ä–∞—Ç—å —É—Ä–æ–≤–µ–Ω—å –∏ —Ä–µ—à–∏—Ç—å –∫–µ–π—Å."
    await callback.message.edit_text(text, reply_markup=get_main_menu())
    await callback.answer()

@router.callback_query(F.data == "task")
async def task_callback(callback: types.CallbackQuery):
    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –≥—Ä–µ–π–¥, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ —Ö–æ—Ç–∏—Ç–µ –ø–æ–ª—É—á–∏—Ç—å –∑–∞–¥–∞–Ω–∏–µ:", reply_markup=get_grades_menu())
    await callback.answer()

@router.callback_query(F.data.startswith("grade_"))
async def handle_grade_selection(callback: types.CallbackQuery, state: FSMContext):
    grade = callback.data.replace("grade_", "")
    question = await generate_question(grade)
    await state.set_state(TaskState.waiting_for_answer)
    await state.update_data(question=question, grade=grade, last_score=0.0)
    await callback.message.edit_text(f"üí¨ –ó–∞–¥–∞–Ω–∏–µ –¥–ª—è —É—Ä–æ–≤–Ω—è {grade}:\n\n{question}\n\n‚úçÔ∏è –ù–∞–ø–∏—à–∏ —Å–≤–æ–π –æ—Ç–≤–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ–º.")
    await callback.answer()

@router.message(TaskState.waiting_for_answer)
async def handle_task_answer(message: types.Message, state: FSMContext):
    data = await state.get_data()
    grade = data.get("grade")
    question = data.get("question")
    last_score = data.get("last_score", 0.0)

    user = get_user_from_db(message.from_user.id)
    student_name = user[2] if user else "—Å—Ç—É–¥–µ–Ω—Ç"

    feedback = await evaluate_answer(question, message.text, student_name)

    match = re.search(r"Score:\s*([0-9.]+)", feedback)
    new_score = float(match.group(1)) if match else 0.0

    if new_score > last_score:
        diff = new_score - last_score
        update_user_points(message.from_user.id, diff)
        update_level(message.from_user.id)
        await state.update_data(last_score=new_score)

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üîÅ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞", callback_data="retry")],
        [InlineKeyboardButton(text="‚úÖ –ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç", callback_data="show_answer")],
        [InlineKeyboardButton(text="üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="main_menu")]
    ])

    await message.answer(f"üìä –û—Ü–µ–Ω–∫–∞ –æ—Ç–≤–µ—Ç–∞:\n{feedback}", reply_markup=keyboard)
    await state.update_data(last_question=question, last_grade=grade)

@router.callback_query(F.data == "show_answer")
async def show_correct_answer(callback: types.CallbackQuery, state: FSMContext):
    data = await state.get_data()
    question = data.get("last_question")
    grade = data.get("last_grade")

    if not question or not grade:
        await callback.message.answer("‚ùå –ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–≥–æ –≤–æ–ø—Ä–æ—Å–∞.", reply_markup=get_main_menu())
        await callback.answer()
        return

    correct = await generate_correct_answer(question, grade)
    await callback.message.answer(f"‚úÖ –≠—Ç–∞–ª–æ–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç:\n\n{correct}", reply_markup=get_main_menu())
    await callback.answer()

@router.callback_query(F.data == "retry")
async def retry_question(callback: types.CallbackQuery, state: FSMContext):
    data = await state.get_data()
    question = data.get("last_question")
    grade = data.get("last_grade")

    if not question or not grade:
        await callback.message.answer("‚ùå –ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–≥–æ –≤–æ–ø—Ä–æ—Å–∞.", reply_markup=get_main_menu())
        await callback.answer()
        return

    await state.set_state(TaskState.waiting_for_answer)
    await callback.message.answer(f"‚úçÔ∏è –ü–æ–≤—Ç–æ—Ä–∏, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–≤–µ—Ç –Ω–∞ –≤–æ–ø—Ä–æ—Å:\n\n{question}")
    await callback.answer()

# --- OpenAI —Ñ—É–Ω–∫—Ü–∏–∏ ---
async def generate_question(grade: str) -> str:
    prompt = f"–°–≥–µ–Ω–µ—Ä–∏—Ä—É–π —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π –≤–æ–ø—Ä–æ—Å –¥–ª—è –ø—Ä–æ–¥–∞–∫—Ç-–º–µ–Ω–µ–¥–∂–µ—Ä–∞ —É—Ä–æ–≤–Ω—è {grade}. –í–æ–ø—Ä–æ—Å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–Ω—è—Ç–Ω—ã–º, –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º –∏ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –±–∞–∑–æ–≤—ã–µ –∑–Ω–∞–Ω–∏—è."
    try:
        response = await asyncio.to_thread(
            client.chat.completions.create,
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "–¢—ã –ø–æ–º–æ–≥–∞–µ—à—å –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã –¥–ª—è –ø—Ä–æ–¥–∞–∫—Ç-–º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=100,
            temperature=0.7
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–æ–ø—Ä–æ—Å–∞: {e}")
        return "‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–æ–ø—Ä–æ—Å–∞."

async def evaluate_answer(question: str, student_answer: str, student_name: str) -> str:
    prompt = (
        f"–í–æ–ø—Ä–æ—Å: {question}\n–û—Ç–≤–µ—Ç —Å—Ç—É–¥–µ–Ω—Ç–∞: {student_answer}\n\n"
        f"–¢—ã –æ–±—Ä–∞—â–∞–µ—à—å—Å—è –∫ —Å—Ç—É–¥–µ–Ω—Ç—É –ø–æ –∏–º–µ–Ω–∏ {student_name}. –û—Ü–µ–Ω–∏ –æ—Ç–≤–µ—Ç –ø–æ —à–∫–∞–ª–µ –æ—Ç 0 –¥–æ 1."
        " –§–æ—Ä–º–∞—Ç:\nScore: <—á–∏—Å–ª–æ>\nFeedback: <–∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π>."
    )
    try:
        response = await asyncio.to_thread(
            client.chat.completions.create,
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "–¢—ã –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å, –æ—Ü–µ–Ω–∏–≤–∞—é—â–∏–π –æ—Ç–≤–µ—Ç—ã —Å—Ç—É–¥–µ–Ω—Ç–æ–≤ —Å—Ç—Ä–æ–≥–æ –ø–æ –∫—Ä–∏—Ç–µ—Ä–∏—è–º."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=200,
            temperature=0.7
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –æ—Ü–µ–Ω–∫–∏ –æ—Ç–≤–µ—Ç–∞: {e}")
        return "‚ùå –û—à–∏–±–∫–∞ –æ—Ü–µ–Ω–∫–∏ –æ—Ç–≤–µ—Ç–∞."

async def generate_correct_answer(question: str, grade: str) -> str:
    prompt = (
        f"–¢—ã –æ–ø—ã—Ç–Ω—ã–π –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å. –î–∞–π –ø–æ–¥—Ä–æ–±–Ω—ã–π –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç –Ω–∞ –≤–æ–ø—Ä–æ—Å –¥–ª—è —É—Ä–æ–≤–Ω—è {grade}.\n\n"
        f"–í–æ–ø—Ä–æ—Å: {question}\n\n"
        "–û—Ç–≤–µ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º, –ø–æ–Ω—è—Ç–Ω—ã–º –∏ –ø–æ–ª–µ–∑–Ω—ã–º –¥–ª—è –æ–±—É—á–µ–Ω–∏—è."
    )
    try:
        response = await asyncio.to_thread(
            client.chat.completions.create,
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "–¢—ã –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—à—å –æ–±—É—á–∞—é—â–∏–µ –æ—Ç–≤–µ—Ç—ã –¥–ª—è —Å—Ç—É–¥–µ–Ω—Ç–æ–≤ –ø–æ –ø—Ä–æ–¥–∞–∫—Ç-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç—É."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=300,
            temperature=0.7
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —ç—Ç–∞–ª–æ–Ω–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞: {e}")
        return "‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —ç—Ç–∞–ª–æ–Ω–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞."

# --- –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ ---
if __name__ == "__main__":
    asyncio.run(dp.start_polling(bot, skip_updates=True))